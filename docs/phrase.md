# Table of Contents

1. [Project Execution & Driving Outcomes](#project-execution--driving-outcomes)
2. [Learning from Experience](#learning-from-experience)
3. [Team Collaboration](#team-collaboration)
4. [Using Data or Logic to Influence](#using-data-or-logic-to-influence)
5. [Leadership Without Title](#leadership-without-title)
6. [Customer Obsession](#customer-obsession)
7. [Feedback (Giving & Receiving)](#feedback-giving--receiving)
8. [Making Trade-offs & Course Correction](#making-trade-offs--course-correction)
9. [Impact-Driven Phrases](#impact-driven-phrases-simple-effective)
10. [Leading](#leading)
11. [Interview Questions](#question)
12. [Metrics & Indicators](#metrics--indicators)
13. [Task Estimation Guide](#task-estimation-guide)

## Project Execution & Driving Outcomes
- I made sure the goals were clear before writing a single line of code.
- I planned the work in small steps so we could stay on track and adjust quickly.
- I talked with the product manager often to make sure we didn‚Äôt miss anything important.
- To avoid delays, I checked in early with the backend team about dependencies.
- I kept the team updated so everyone knew what to expect and when.

## Learning from Experience
- That project didn‚Äôt go as planned, but I learned a lot from it.
- I made a mistake, but I took notes and shared what I learned with the team.
- After the release, I looked back at what worked and what didn‚Äôt.
- Next time, I used what I learned to improve how I planned my tasks.
- I now check more often with others to catch problems early.
- That mistake helped me understand how important early communication is.
- After that project, I started double-checking assumptions before writing code.
- I now make sure to get feedback early instead of waiting until the end.
- Looking back, I should‚Äôve asked more questions‚Äînow I always clarify before diving in.
- It taught me to slow down and focus on the problem before jumping into the solution.
- I realized I needed to involve the QA team earlier, and that made a big difference next time.
- That experience showed me how valuable pair programming can be during tricky parts.
- Since then, I‚Äôve been more proactive in raising concerns before they become blockers.
- I learned that even small UI bugs can have a big impact on users.
- Now I always do a quick post-release review, so I don‚Äôt repeat the same mistake.

## Team Collaboration
- I like working closely with others to solve problems together.
- When someone got stuck, I offered to help and we fixed it faster as a team.
- I made sure to keep the designer in the loop so the UI turned out right.
- I try to make it easy for others to understand my code and jump in if needed.
- We held a quick sync every day to stay aligned and support each other.

## Using Data or Logic to Influence
- I showed numbers to back up my idea, and it helped the team agree.
- We looked at past bugs to decide the best way forward.
- I shared user feedback to explain why the change mattered.
- Instead of arguing, I shared a quick prototype so people could see the result.
- I listened to their view and explained mine clearly with real examples.

##  Leadership Without Title
- I saw something we could improve, so I took the lead to fix it.
- Even though I wasn‚Äôt the tech lead, I helped guide the direction of the project.
- I mentored a new teammate so they could work more independently.
- I raised concerns early so the whole team could make better choices.
- I suggested a better way of doing things and got others on board.

##  Customer Obsession
- When something broke for a user, I fixed it fast and followed up.
- I always think about how the user will feel when using our product.
- I watched real user sessions to understand their pain points.
- I once shipped a bug, but I owned it and made sure it didn‚Äôt happen again.
- The customer‚Äôs voice matters most to me when making decisions.

##  Feedback (Giving & Receiving)
- I asked my teammate for feedback so I could improve my approach.
- When I saw something that could be better, I gave honest but kind feedback.
- I take feedback seriously and try to apply it right away.
- We do retros after projects, and I always speak up and share ideas.
- I told my manager what was working and what could be better for the team.

## Making Trade-offs & Course Correction
- We had to change plans mid-way, and I helped the team adapt quickly.
- When a feature was too complex, I suggested a simpler first version.
- We missed something in the early design, but I helped fix it fast.
- I focused on what mattered most to users and cut the rest.
- Sometimes speed matters more than perfection, so I picked what worked best for now.

## Impact-Driven Phrases (Simple, Effective)
- Because of my work, users were able to complete tasks faster and with fewer clicks.
- My refactor cut page load time in half, which improved user experience right away.
- The component library I built helped other developers move faster and stay consistent.
- I fixed a recurring bug that had been frustrating users for months.
- After I introduced the new testing process, we caught more issues before release.
- My changes reduced the need for design handovers, saving both dev and design time.
- Thanks to my idea, we avoided a major delay and still launched on time.
- I spotted an accessibility issue early and made sure we met compliance before launch.
- I led a small initiative that improved code quality across the whole frontend team.
- My proactive communication helped align product, design, and engineering, avoiding last-minute rework.


## Leading
- Requirement Understanding
	‚Ä¢	Collaborate with product managers, designers, and backend engineers to understand project requirements.
	‚Ä¢	Clarify user stories, business goals, and constraints.
	‚Ä¢	Break down complex features into manageable frontend components.

- Planning & Task Breakdown
	‚Ä¢	Identify key components/pages, state management needs, and third-party dependencies.
	‚Ä¢	Define technical stack (e.g., React/Vue, TypeScript, Tailwind, Redux, etc.).
	‚Ä¢	Break down work into tasks and subtasks using tools like Jira, Trello, or Linear.
	‚Ä¢	Prioritize tasks based on dependencies and team bandwidth.

- Assigning Tasks
	‚Ä¢	Match tasks with team members‚Äô strengths and growth goals.
	‚Ä¢	Ensure knowledge sharing and balance between juniors and seniors (e.g., pair programming).

- Setup & Standards
	‚Ä¢	Establish project architecture, folder structure, and coding guidelines (linting, naming conventions, etc.).
	‚Ä¢	Set up CI/CD pipelines, testing frameworks (Jest, Playwright, etc.), and environment configs.

- Development & Support
	‚Ä¢	Conduct regular check-ins (standups or async updates).
	‚Ä¢	Provide code reviews and unblock teammates quickly.
	‚Ä¢	Encourage feature flags and frequent commits to reduce merge conflicts.

- Quality Assurance
	‚Ä¢	Enforce unit and integration testing.
	‚Ä¢	Collaborate with QA for user testing and bug triage.
	‚Ä¢	Track performance metrics and accessibility compliance.

- Deployment & Monitoring
	‚Ä¢	Coordinate frontend deployments with backend/API readiness.
	‚Ä¢	Monitor production (using tools like Sentry, LogRocket, Lighthouse) and fix issues quickly.

- Retrospective & Improvements
	‚Ä¢	Hold sprint retros to gather feedback.
	‚Ä¢	Reflect on team productivity, code quality, and pain points.
	‚Ä¢	Update documentation and onboard new best practices as needed.

## Question
üõ†Ô∏è To show continued interest in the role
4.	‚ÄúFrom your perspective, what challenges is the frontend team currently focusing on?‚Äù
5.	‚ÄúWhat would success look like in the first 3‚Äì6 months for someone in this role?‚Äù
6.	‚ÄúIs there a specific tech stack or architecture that I should familiarize myself with to be most effective here?‚Äù

How does the team define and measure success for the products you build?

How do engineers typically collaborate across teams or orgs at Amazon?

How does mentorship work here, both for giving and receiving?

What does career growth look like for an SDE II in your team?
‚∏ª

üå± To demonstrate growth mindset and team fit
7.	‚ÄúAre there any key traits or working styles that stand out in successful frontend engineers at Atlassian?‚Äù
8.	‚ÄúWhat do you think distinguishes the frontend culture at Atlassian from other companies?‚Äù

## Metrics & Indicators:
	1.	Business Impact:
	‚Ä¢	The collaboration feature played a key role in helping the client sign the company‚Äôs largest contract to date. That‚Äôs a very clear ROI and validates the value of the feature.
	2.	Timeline:
	‚Ä¢	We delivered a functional live collaboration prototype within 3 weeks, which was in time for a critical US conference. That speed of delivery was crucial for business momentum.
	3.	Client Satisfaction:
	‚Ä¢	The client gave very positive feedback on the collaboration experience, particularly praising the real-time sync, offline support, and conflict resolution‚Äîall of which were key requirements.
	4.	Technical Outcome:
	‚Ä¢	We successfully implemented the version-detection model using Yjs and WebRTC, which worked reliably in the demo. This was our first use of CRDT in production, and it performed well under real-world scenarios.
	5.	Strategic Foundation:
	‚Ä¢	We laid out a clear upgrade path to a more robust client-server model for long-term scalability. This future-proofed the solution beyond just the demo.


	üîç 1. Understand the Requirements Thoroughly
	‚Ä¢	Clarify the user story, design, edge cases, and performance expectations.
	‚Ä¢	Ask: What does ‚Äúdone‚Äù mean? Does it include testing, cross-browser support, accessibility, etc.?

‚∏ª
## Task Estimation Guide
üß± 2. Break the Task Into Subtasks

For example, a ‚Äúbuild login screen‚Äù task might break into:
	‚Ä¢	Layout with responsive design
	‚Ä¢	Form validation
	‚Ä¢	API integration for login
	‚Ä¢	Error handling
	‚Ä¢	Unit & integration tests
	‚Ä¢	Mobile/device testing
	‚Ä¢	Code review & deployment

‚∏ª

‚è± 3. Estimate Each Subtask Individually

Use time blocks (e.g., 1h, 2h, 4h, 1d). Prefer ranges if there‚Äôs uncertainty:

e.g., Form validation: 1‚Äì2 hours

If you‚Äôre unsure, apply:
	‚Ä¢	T-shirt sizing (S/M/L) first
	‚Ä¢	Then translate to time once scope is clearer

‚∏ª

üîÅ 4. Factor in Hidden Costs

Add time buffers for:
	‚Ä¢	Bug fixing & debugging
	‚Ä¢	Back-and-forth with designers/product managers
	‚Ä¢	QA/testing
	‚Ä¢	Environment setup or API issues

General buffer rule: add 20‚Äì30% padding

‚∏ª

üß† 5. Use Historical Data

If similar features have been implemented before:
	‚Ä¢	Look at past Jira tickets
	‚Ä¢	Ask teammates what their timing was

‚∏ª

üìä 6. Apply an Estimation Technique (optional)
	‚Ä¢	Planning Poker (team-based)
	‚Ä¢	Three-point estimation (PERT):
Expected Time = (Optimistic + 4 √ó Most Likely + Pessimistic) √∑ 6
	‚Ä¢	RADIO for larger systems: Requirements, Architecture, Data, Integration, Operations

‚∏ª

‚úÖ 7. Document Assumptions

Clarify dependencies or blockers:

‚ÄúThis estimate assumes the API is ready and stable.‚Äù

‚∏ª
